

Cicd Assistant
==============



About
-----

This application is a standalone server providing some features helpful for 
setting up and performing cicd tasks.



Features:
---------

* It serves as a PACT broker
  * provides push operation: contract collection (pact) will be ready for download by clients
  * provides pull operation: clients will download the contract collection (pact)
  * provides store operation: stores a contract collection (pact) corresponding with a tag, but still its not selected for being downloaded
  * provides elect operation: sets a contract collection (pact), the one that will be downloaded by clients
* It serves as a badge broker based on tags
  * Success badge
  * Failure badge
  * Pending badge (Otherwise)
  * Can serve badges with svg or png formats
* Provides Api calls for sending emails
  * Uses smtp server address and credentials from configurations
  * Api for self-contained email body 
  * Api for template based email body
  * Api for registering templates
* Provides an artifact server
  * artifacts can be uploaded to artifacts server through multipart post call to artifacts/upload
  * uploaded artifacts can be downloaded by their names from artifacts/<artifact-file-name>


Pact Broker Api
====================

You can use pact broker api directly by making calls to these endpoints:

Pull
----

This endpoint will return main contract collection (Pact) if any is delivered 
at the moment.

|                       |                           |
|:---------------------:|:-------------------------:|
|endpoint path          |  <base-url>/pull          |
|Http Method            |  GET                      |
|Headers                |  token: <token>           |


__Response__ when a pact is present:


```json
{
    "model": {
        "contracts": [
            {
                "consumer": {
                    "name": "authentication"
                },
                "provider": {
                    "name": "v1"
                },
                "interactions": [...],
                "metadata": {
                    "pactSpecification": {
                        "version": "3.0.0"
                    }
                }
        ]
    },
    "failure": false,
    "error": ""
}

```

__Response__ when __No__ pacts are present yet:

```json
{
    "model": null,
    "failure": true,
    "error": {
        "message": "Not found",
        "code": 404
    }
}

```

Push
-------

Push endpoint sets a contract collection (Pact) as the main delivered pact on 
the broker.

|                       |                           |
|:---------------------:|:-------------------------:|
|endpoint path          |  <base-url>/push          |
|Http Method            |  POST                     |
|Headers                |  token: <token>           |

__Request Body__:

```json
{
        "contracts": [
            {
                "consumer": {
                    "name": "authentication"
                },
                "provider": {
                    "name": "v1"
                },
                "interactions": [...],
                "metadata": {
                    "pactSpecification": {
                        "version": "3.0.0"
                    }
                }
        ]
    }
```

__Response__:

```json
{
    "model": {
        "contracts": [
            {
                "consumer": {
                    "name": "authentication"
                },
                "provider": {
                    "name": "v1"
                },
                "interactions": [...],
                "metadata": {
                    "pactSpecification": {
                        "version": "3.0.0"
                    }
                }
        ]
    },
    "failure": false,
    "error": ""
}

```

Store
------


In many cases, its more desired to produce pact files at one point of the ci 
pipeline, and send them to the broker in another point. For example you might 
want to review the merge request after it's tests are passed (so pact files are 
already generated, and set these files to broker when the merge request is 
accepted and merged into the main branch (usually develop) so the pacts in broker 
would be the ones actually generated by last merged code. In such cases you can 
use store and elect apis. store api will deliver pact files to broker alongside a 
tag. (I use branch head as a tag) and when the branch is merged, you would 
call elect with that exact tag to tell the broker this is the pact data that 
should be served through pull api.

|                       |                           |
|:---------------------:|:-------------------------:|
|endpoint path          |  <base-url>/store/<tag>   |
|Http Method            |  POST                     |
|Headers                |  token: <token>           |

__Request Body__:

```json
{
        "contracts": [
            {
                "consumer": {
                    "name": "authentication"
                },
                "provider": {
                    "name": "v1"
                },
                "interactions": [...],
                "metadata": {
                    "pactSpecification": {
                        "version": "3.0.0"
                    }
                }
        ]
    }
```

__Response__:


```json
{
    "model": null,
    "failure": false,
    "error": {
        "message": "Ok",
        "code": 200
    }
}
```

Elect
------

This api will elect a stored contract collection (Pact) by it's tag as the main 
pact to be delivered via pull api.

|                       |                           |
|:---------------------:|:-------------------------:|
|endpoint path          |  <base-url>/elect/<tag>   |
|Http Method            |  POST                     |
|Headers                |  token: <token>           |

__Response__:

The elect api will respond with elected pact.

```json
{
    "model": {
        "contracts": [
            {
                "consumer": {
                    "name": "authentication"
                },
                "provider": {
                    "name": "v1"
                },
                "interactions": [...],
                "metadata": {
                    "pactSpecification": {
                        "version": "3.0.0"
                    }
                }
        ]
    },
    "failure": false,
    "error": ""
}

```

Badge Broker Api
=============

The badge broker service, currently provides badges for successful,failed and 
pending (or unknown) statuses. 

It can register/update one or more tags with a success or failure state, via 
badges api (POST), and in result, a (GET) call to badges endpoint will provide 
suitable image with previously registered status. 

Badges (POST)
-----------

|                       |                           |
|:---------------------:|:-------------------------:|
|endpoint path          |  <base-url>/badges        |
|Http Method            |  POST                     |
|Headers                |  token: <token>           |


__Request Body__:

```json
{
    "tag1":"Success",
    "tag2":"Failure",
    ...
}
```
__Response__:

```json
{
    "model": {
        "tag1": "Success"
        "tag2": "Failure",
        ...
    },
    "failure": false,
    "error": ""
}

```

Badges (GET) image url:
--------------------

To get badges, you just add the tag at eht end of the url 
```<base-url>/badges/svg``` to get a svg format badge, or use 
```<base-url>/badges/png``` for png format.

|                                        |                                     |
|:--------------------------------------:|:-----------------------------------:|
|<base-url>/badges/png/tag-sucessfull    |![Badge](Graphics/Badges/success.png)|
|<base-url>/badges/png/tag-failed        |![Badge](Graphics/Badges/failure.png)|
|<base-url>/badges/png/tag-not-registered|![Badge](Graphics/Badges/unknown.png)|



Multipart Download
---------------------

For implementing Multipart (resumable) downloads, i used the code from 
[davinkevin](https://github.com/davinkevin/Podcast-Server/blob/d927d9b8cb9ea1268af74316cd20b7192ca92da7/src/main/java/lan/dk/podcastserver/utils/multipart/MultipartFileSender.java)
 which is working pretty well.
